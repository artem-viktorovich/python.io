


## Изменение объектов в Python

Переменная содержит ссылку на объект и с помощью id можно узнать ячейку

Переменные могут ссылаться на один объект в памяти

> Адреса неизменяемых объектов

```python
my_number = 10  
print(id(my_number))  #140727532192968
  
other_number = 10  
print(id(other_number))  #140727532192968
  
print(id(10))  #140727532192968
```

В данном примере обращение к постоянному неизменяемому значение в ячейке памяти

```python
first_num = 10  
second_num = first_num  
  
print(id(first_num), id(second_num))  

#140727532192968 140727532192968

second_num += 4  # создание нового объекта
print(id(first_num), id(second_num))

#140727532192968 140727532193096
```

#### Поведение изменяемых объектов

##### Пример 1 - список

```python
my_list = [1,2,3,4,5]
print(id(my_list))  #2661862713088
  
other_list = [1,2,3,4,5]
print(id(other_list))  #2661862563968
  
print(id([1,2,3,4,5]))  #2661862521728
```

##### Пример 2 - словарь

```python
info = {  
    'name': 'Artem',  
    'age': 28,  
}  
info_copy = info  
print(id(info_copy))  #2161184138176
print(id(info), info)  
# 2161184138176 {'name': 'Artem', 'age': 28}

"""Копируем только ссылку"""
```

Добавим новый ключ с новым значением

```python
info = {  
    'name': 'Artem',  
    'age': 28,  
}  
info_copy = info  
info['reviews_qty'] = 5  
print(id(info_copy))  #1766475752384
print(id(info), info)  #1766475752384 {'name': 'Artem', 'age': 28, 'reviews_qty': 5}

"""Созданы новые ячейки в памяти"""
```

##### Пример 3 - словарь

```python
my_info = {  
    'name': 'Artem',  
    'age': 28,  
}  
other_info = {  
    'name': 'Anton',  
    'age': 22,  
}  
print(id(my_info), id(other_info))  #1520810255296 1520810651968
```

Добавим ключ во второй словарь
```python
my_info = {  
    'name': 'Artem',  
    'age': 28,  
}  
other_info = {  
    'name': 'Anton',  
    'age': 22,  
}  
other_info['rating'] = 4.0  
print(id(my_info), id(other_info))  #2510134764480 2510135161152

"""Адреса изменились"""
```

#### Изменения копий

> Как избежать изменения копий

Пример 1

```python
my_info = {  
    'name': 'Artem',  
    'age': 28,  
}  
other_info = my_info.copy()  
other_info['rating'] = 4.0  
print(my_info)  #{'name': 'Artem', 'age': 28, 'reviews': ['Great course!']}
print(other_info)  #{'name': 'Artem', 'age': 28, 'reviews': ['Great course!']}

"""За счёт копирования таким способом, остаются ссылки, ибо копирование поверхностное"""
```

Для полного копирования объекта нужно использовать функцию _**deepcopy()**_ импортируя модуль _**copy**_

```python
from copy import deepcopy 
  
my_info = {  
    'name': 'Artem',  
    'age': 28,  
    'reviews': []  
}  
info_copy = deepcopy(my_info)
info_copy['reviews'].append('Great course!')  
print(my_info)  #{'name': 'Artem', 'age': 28, 'reviews': []}
print(info_copy)  #{'name': 'Artem', 'age': 28, 'reviews': ['Great course!']}
```
## Функции

> _**Функция**_ - блок кода, который можно выполнять многократно

```python
def sum(a, b):  # функция с именем
    c = a + b  # тело функции
    print(c)  


a = 5  
b = 6  
sum(a, b)  # вызов функции

#11

a = 9  
b = 6  
sum(a, b)

#15



"""Функция используется многократно, для вывода разных результатов"""
```

> _**Функция**_ это объект, как всё в Python - <class 'function'>

> Функция возвращает _**None**_, если нет ключевого слова _**return**_

```python
def sum(a, b):  
    c = a + b  
  
print(sum(3, 4))  # None

def sum(a, b):  
    c = a + b  
    return c  
  
print(sum(3, 4))  # 7
```

#### Функция _**pass**_

Функция `pass` в Python используется в качестве заполнителя, когда нужно написать код позже или просто требуется выполнить синтаксическую структуру языка (например, создать тело класса, функции или цикла), но не добавлять никакого конкретного действия.

Это может быть полезно для:

- Создания скелета программы перед добавлением функциональности.
- Формирования шаблонов для будущих функций или классов.
- Указания на то, что блок кода должен быть написан в будущем.

Использование `pass` позволяет избежать ошибок и предупреждений от интерпретатора Python, связанных с отсутствием кода там, где он ожидается.

## Передача неизменяемых объектов в функцию

В Python передача неизменяемых объектов (таких как строки, числа и кортежи) в функции происходит по значению. Это означает, что при передаче объекта в функцию создаётся копия значения аргумента, которая затем используется внутри функции.

При изменении такого объекта внутри функции изменения не будут отражены за пределами функции, так как была создана новая копия. Однако если функция возвращает изменённый объект, то эти изменения будут видны снаружи.

Пример:

```python
def my_function(my_string):
    my_string = my_string + " World!"
    return my_string

my_greeting = "Hello"
modified_greeting = my_function(my_greeting)
print("Inside function:", modified_greeting)  # Prints "Hello World!"
print("Outside function:", my_greeting)     # Prints "Hello"
```

В этом примере строка «Hello» передаётся в функцию `my_function`, где она изменяется. Но поскольку строка является неизменяемым объектом, изменение копии внутри функции не влияет на оригинал. Чтобы увидеть изменения, нужно присвоить результат функции другой переменной.


## Передача изменяемых объектов в функцию

```python
def increase_person_age(person):  
    person['age'] += 1  
    return person  


person_one ={  
    'name': 'Bob',  
    'age': 21,  
}  
  
increase_person_age(person_one)  
print(person_one['age'])  #22
```

В данном примере функция `increase_person_age` принимает один аргумент — словарь `person`, который является изменяемым объектом. Внутри функции значение ключа `'age'` увеличивается на 1 с помощью операции `+=`. Затем функция возвращает изменённый словарь.

В основной части кода создаётся словарь `person_one` с данными о человеке. Затем вызывается функция `increase_person_age`, передавая ей словарь `person_one`. После вызова функции печатается значение ключа `'age'`, которое теперь равно 22.

Таким образом, изменения, сделанные внутри функции, отражаются в исходном словаре, поскольку он был передан по ссылке. Это особенность работы с изменяемыми объектами в Python.

> Внутри функции _**не рекомендуется**_ изменять _**внешние_** объекты

#### Как избежать изменения внешних объектов в функции

```python
def increase_person_age(person):  
    person_copy = person.copy()  #создаём копию внутри функции задавая новую переменную, тем самым не затрагивая внешние ссылки
    person_copy['age'] += 1  
    return person_copy  
  
  
person_one = {  
    'name': 'Bob',  
    'age': 21,  
}  
  
new_person = increase_person_age(person_one)  
print(new_person['age'])  #22
print(person_one['age'])  #21
```

Чтобы избежать изменения внешних объектов в функции в Python, можно использовать несколько подходов:

1. **Копирование объекта.** Создайте копию переданного объекта внутри функции с помощью методов копирования или срезов. Это позволит вам работать с копией объекта, не затрагивая оригинальный объект.
    
2. **Использование неизменяемых типов данных.** Если возможно, используйте неизменяемые типы данных, такие как строки, числа и кортежи. Они не могут быть изменены после создания, что предотвращает случайное изменение внешних объектов.
    
3. **Возврат нового объекта.** Вместо изменения переданного объекта создайте новый объект внутри функции и верните его. Таким образом, вы сможете контролировать, какие изменения будут внесены во внешний мир.
    
4. **Передача копии объекта.** При вызове функции передайте копию объекта, используя методы копирования или срезы. Это гарантирует, что функция будет работать только с копией, а не с исходным объектом.
    
5. **Использование аргументов только для чтения.** В некоторых случаях можно использовать аргументы только для чтения, чтобы предотвратить их изменение внутри функции. Однако это может привести к ошибкам, если функция попытается изменить объект, который был передан как аргумент только для чтения.
    
6. **Применение функций высшего порядка.** Используйте функции высшего порядка, которые принимают другие функции в качестве аргументов и возвращают новые функции. Это позволяет контролировать доступ к внешним объектам и предотвращать их случайное изменение.
    
7. **Использование контекстных менеджеров.** Контекстные менеджеры предоставляют возможность управлять ресурсами и объектами, гарантируя их безопасное использование и освобождение. Они могут помочь предотвратить случайное изменение объектов внутри функции.
    
8. **Возвращение изменённого объекта.** Верните изменённый объект из функции, но сохраните исходный объект без изменений. Это даст возможность контролировать процесс внесения изменений и при необходимости откатиться к первоначальному состоянию.
    

Выбор подхода зависит от конкретной ситуации и требований  проекта.

> Задача
- Создайте функцию merge_lists_to_dict
- У функции должно быть два параметра
- Функция должна объединить два списка, используя встроенную функцию zip
- Конвертируйте объект zip в словарь и верните его из функции
- Вызовите функцию, передав ей два списка в качестве аргументов
- Выведите результат вызова функции в терминал

>Решение

```python
def  merge_lists_to_dict(a, b):  
    create_zip_list = zip(a, b)  # <zip object at 0x000002BC6A8FC4C0>
    create_dict_list = dict(create_zip_list)  
    return create_dict_list
  
  
list1 = [1, 2, 3]  
list2 = [4, 5, 6]  
  
result = merge_lists_to_dict(list1, list2)  
print(result)  #{1: 4, 2: 5, 3: 6}
```

### Аргументы с ключевыми словами

```python
def get_posts_info(name, posts_qty):  
    info = f"{name} wrote {posts_qty} posts"    
    return info  
  
  
info = get_posts_info(name='Artem', posts_qty=29)  
print(info)  # Artem wrote 29 posts

""" 
В данном примере аргументы с ключевыми словами внесены в функцию, поэтому порядок аргументов не важен
"""
```

> Использование аргументов с ключевыми словами делает код более _**читабельным

### Объединение именованных аргументов в словарь

```python
def get_posts_info(**person):  
    print(person)  # {'name': 'Artem', 'posts_qty': 29}
    info = f"{person['name']} wrote {person['posts_qty']} posts"    
    return info  
  
  
info = get_posts_info(name='Artem', posts_qty=29)  
print(info)  # Artem wrote 29 posts
```

Функция **get_posts_info** принимает один аргумент — словарь с данными о пользователе (аргумент person). В этом словаре есть два ключа: name и posts_qty.

Функция выводит на экран содержимое словаря и формирует строку с информацией о пользователе, используя ключи name и posts_qty из словаря. Затем функция возвращает эту строку.

В основной части кода мы вызываем функцию get_posts_info и передаём ей словарь с ключами name и posts_qty, где name имеет значение 'Artem', а posts_qty — значение 29. Результат вызова функции сохраняется в переменной info.

Таким образом, функция get_posts_info позволяет получить информацию о пользователе в виде строки.


> Задача 1
- Переписать вызов функции _merge_lists_to_dict_ из предыдущей задачи так, чтобы в нём использовались аргументы с ключевыми словами
- Добавить ещё один вызов функции, в котором будет один позиционный аргумент, а второй - аргумент с ключевым словом

> Решение

```python
brand = ['BMW', 'Audi', 'Toyota']  
price = [30000, 35000, 28000]  
  
  
def merge_lists_to_dict(brand, price):  
    create_zip_list = zip(brand, price)  
    return dict(create_zip_list)  
  
  
print(merge_lists_to_dict(brand, price))  
# {'BMW': 30000, 'Audi': 35000, 'Toyota': 28000}  
  
# вызов с 2мя позиционными значениями  
  
print(merge_lists_to_dict(brand=brand, price=price))  
{'BMW': 30000, 'Audi': 35000, 'Toyota': 28000}  
# {'BMW': 30000, 'Audi': 35000, 'Toyota': 28000}  
  
# вызов с 1 позиционным значением  
print(merge_lists_to_dict(brand, price=price))  
# {'BMW': 30000, 'Audi': 35000, 'Toyota': 28000}
```

> Задача 2
- Создать функцию _update_car_info_, в которой все именованные аргументы будут объединяться в словарь _car_
- Добавить в словарь ключ _is_available_ с значением _True_
- Вернуть из функции изменённый словарь
- Вызвать функцию с именованными аргументами _brand_ и _price_, их значения могут быть любыми
- Вывести в терминал результат функции

> Решение

```python
def update_car_info(**car):
    print(car)  #{'brand': 'BMW', 'price': 30000}
    car['is_available'] = True
    return car


info = update_car_info(brand='BMW', price=30000)
print(info)  #{'brand': 'BMW', 'price': 30000, 'is_available': True}

```

## Параметры функции по умолчанию

```python
def mult_by_factor(value, multiplier=1):  
    return value * multiplier  


print(mult_by_factor(10, 2))  # 20
print(mult_by_factor(5))  #5
```

Функция `mult_by_factor` принимает два аргумента: `value` и `multiplier`. Она умножает `value` на `multiplier` и возвращает результат.

Если для `multiplier` не указано значение, то по умолчанию используется `1`. Это позволяет функции работать без указания множителя, если нужно просто умножить число на единицу.

Пример использования функции:

- `print(mult_by_factor(10, 2))` — здесь функция вызывается с аргументом `multiplier=2`, поэтому она умножает 10 на 2 и возвращает 20. Результат выводится на экран.
- `print(mult_by_factor(5))` — в этом случае функция вызывается без указания `multiplier`, поэтому используется значение по умолчанию `multiplier=1`. Функция умножает 5 на 1 и возвращает 5. Результат также выводится на экран.


## Колбэк функции 

Колбэк функция в Python — это функция, которая передаётся в другую функцию в качестве аргумента и вызывается внутри этой другой функции. Это позволяет сделать код более гибким и расширяемым.

```python
def приветствие(name):
    print(f"Привет, {name}!")


def обработка_имени(callback, name):
    # Здесь вызываем колбэк функцию
    callback(name)

# Передаём функцию приветствие как колбэк
обработка_имени(приветствие, "Алексей")
```


В этом примере:
- Функция `приветствие` принимает имя и выводит приветствие.
- Функция `обработка_имени` принимает функцию (колбэк) и имя, затем вызывает колбэк с переданным именем.

Колбэки часто используют в асинхронном программировании, обработке событий и других сценариях, когда необходимо выполнить некоторую логику по завершении действий.


## Правила работы с функциями

1. Называть функции исходя из выполняемых задач
2. Название функции начинать с _**глагола**_
3. _**Одна**_ функция должна выполнять **_одну задачу**_
4. Не рекомендуется изменять _внешние_ относительно функции _**переменные**_


## Документация функции _**docstring**_

Добавление описания функции

> _**docstring**_ - используется для документирования функций, классов, модулей

```python
def mult_by_factor(value, mult=1):  
    """
    Multiplies number by multiplier.        
    """    
    return value * mult  
  
  
print(mult_by_factor(2))  # 2
print(mult_by_factor(3))  # 3


#Умножает число на множитель
```

```python
def print_number_info(num):  
    """  
    Prints whether number is even or odd  
            Args:       
               num (int): number to be evaluated    """    if (num % 2) == 0:  
        print("Num is even")  
    else:  
        print("Num is  odd")  
  
print_number_info(5)  
  
  
"""  
	Выводит, является ли число четным или нечетным                   
	    Аргументы:  
           num (int): вычисляемое число
"""
```

## Области видимости

> _Область видимости_ - определяет границы действия переменной

_ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ VS ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ_

> Локальные переменные не доступны глобальным, а глобальные, доступны локальным

```python
a = 10  
  
  
def my_fn():  
    a = True  
    b = 15  
    print(a, b)  
  
  
my_fn()  # True 15
  
print(a)  # 10
print(b)
"""
Traceback (most recent call last):
  File "D:\Обучалка\Python\python\main.py", line 11, in <module>
    print(b)
          ^
NameError: name 'b' is not defined

Попытка вывести значение переменной `b` вне функции приведёт к ошибке, так как переменная `b` является локальной для функции `my_fn` и не существует за её пределами.

"""
```

#### Типы областей видимости

1. Глобальная область видимости
2. Область видимости функции

В программировании существует два основных типа областей видимости: **глобальная** и **локальная**.

**Глобальная область видимости** — это область, в которой переменная доступна для использования во всей программе. Она объявляется вне функций и циклов. Переменные, объявленные в глобальной области видимости, доступны для всех функций в коде.

**Локальная область видимости**, напротив, ограничена функцией или блоком кода. Переменная, объявленная внутри функции, доступна только внутри этой функции. Как только выполнение функции завершается, локальные переменные удаляются из памяти.

Когда функция вызывает другую функцию, она создаёт новую область видимости. Это означает, что переменные, объявленные внутри одной функции, не доступны в другой функции, если они не переданы как аргументы или не возвращены как результат.

Важно понимать различия между этими областями видимости, чтобы избежать ошибок и неожиданного поведения программы. Например, изменение глобальной переменной внутри функции может привести к ошибкам, так как другие части программы также могут использовать эту переменную.

Чтобы предотвратить такие проблемы, рекомендуется объявлять переменные в локальной области видимости и передавать их в качестве аргументов функциям, которые в них нуждаются. Это делает код более модульным и упрощает его понимание и отладку.


## Ключевое слово _global_ в функциях

```python
a = 10  
  
  
def my_fn():  
    global b  # вывели переменную в глобальную, тем самым дали доступ к неё
    a = True  
    b = 15  
    print(a, b)  
  
  
my_fn()  # True 15
  
print(a)  # 10 
print(b)  # 15
```


## Операторы

| Арифметические операторы | Операторы сравнения | Логические операторы | Оператор присвоения |
| ------------------------ | ------------------- | -------------------- | ------------------- |
| +                        | ==                  | not                  | =                   |
| -                        | !=                  | and                  |                     |
| *                        | <                   | or                   |                     |
| /                        | >                   | is                   |                     |
|                          | >=                  | is not               |                     |
|                          | <=                  | in                   |                     |
|                          |                     | not in               |                     |

_**is**_ - оператор проверки совпадения объектов

```python
a = 10  
b = a  
c = a + b  
  
print(a is b)  # True совпадение id
print(a is c)  # False не совпадают id
```


### Операторы и магические методы

> У операторов есть соответствующие магические методы классов

```python
a == b 
#равносильно записи ниже
a.__eq__(b)


a = [1,2]  
b = [1,2]  
print(a == b)  # True
  
print(a.__eq__(b))  # True

print(a.__eq__)  # <method-wrapper '__eq__' of list object at 0x000002A3B90DA700>
```

### Функция _**dir**_

> _**dir**_ - выводит список имён атрибутов определённого элемента

```python
print(dir(list))
```

> ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

```python
print(dir(dict))
```

>['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

### Унарные и бинарные операторы

> Унарные операторы всегда имеют один операнд

```python
my_num = 10  
print(+my_num)
```

В данном коде происходит следующее:

1. Объявление переменной: my_num = 10 — здесь создаётся переменная my_num и ей присваивается значение 10.

2. Вывод значения: print(+my_num) — эта строка выводит значение переменной my_num на экран. Знак + перед переменной не изменяет её значение, он просто указывает, что мы выводим значение как положительное число. В данном случае это избыточно, так как my_num уже положительное.

Таким образом, на экране будет выведено 10.

```python
my_bool = True  
print(+my_bool)
```

При использовании знака + перед булевым значением True, Python автоматически преобразует его в числовой тип. В этом случае True будет преобразовано в 1.

> У бинарных операторов два операнда


```python
a = 5
a + b
a += 5
a == b
a and b
```

### Инфиксная запись

> Инфиксная записьn — это способ записи математических операций, когда оператор находится между операндами. Например, в выражении a + b, оператор + находится между переменными a и b. 

В Python можно использовать инфиксную запись для различных арифметических операций, логических операций и даже операций сравнения.

- Арифметика: x * y, a - b
- Логика: is_true and is_false, x or y
- Сравнение: a < b, c >= d

Инфиксная запись удобна для чтения и восприятия, поскольку она соответствует привычному математическому стилю записи выражений.

#### Операторы _**in, not in**_

```python
my_car = {  
    'brand': 'Ford',  
    'model': 'Mustang',  
}  
  
print('brand' in my_car)  # True
print('model' in my_car)  # True
print('car' in my_car)  # False
print('car' not in my_car)  # True

# Проверка присутствия элемента в последовательности
```

### Ложные значения

> Значение, которое при приведении к логическому типа даёт _false_, является _ложным_

Ложные значения
1. int   0
2. float  0.0
3. complex 0j

Как определить ложное значение? Только вызовом функции _bool_

```python
print(bool(0))  # False
print(bool(0.0))  # False
print(bool(0j))  # False
print(bool(None))  # False
```

Ложными также являются все пустые последовательности

1. dict {}
2. list []
3. tuple ()
4. set set()
5. range range(0)
6.  str ""

```python
print(bool({}))  # False
print(bool([]))  # False
print(bool(()))  # False
print(bool(set()))  # False
print(bool(range(0)))  # False
print(bool(""))  # False
```

bool можно заменить конструкцией not not

```python
print(not not({}))  # False
print(not not([]))  # False
print(not not(()))  # False
print(not not(set()))  # False
print(not not(range(0)))  # False
print(not not(""))  # False
```

## Логические операторы

_**not**_ - всегда возвращает значение типа _bool_
_**and**_ и _**or**_ - возвращает значение одного из операндов

> Оператор _not_ чаще всего используется в условных инструкциях _if_

> Примеры с оператором _not_

```python
print(not 10)  # False
print(not 0)  # True
print(not 'abc')  # False
print(not '')  # True
print(not True)  # False
print(not None)  # True
```

Отрицание отрицания - _not not_

```python
print(not not 10)  # True
print(not not 0)  # False
print(not not 'abc')  # True
print(not not '')  # False
print(not not True)  # True
print(not not None)  # False
```

### Операторы короткого замыкания _or_ и _and_

> Операторы _or_ и _and_ являются операторами короткого замыкания (short-circuit)

> Оператор and - инфиксный бинарный оператор

```python
Выражение 1 and Выражжение 2
```

Если "Выражение 1" ложно:
1. Выражение 2 игнорируется
2. Возвращается результат "Выражение 1"

> Оператор or - инфиксный бинарный оператор, имеет 2 операнда

```python
Выражение 1 or Выражжение 2
```

Если "Выражение 1" истинно:
1. Выражение 2 игнорируется
2. Возвращается результат "Выражение 1"

#### Цепочка операторов _or_ и _and_

a and and b and c and d - везде истина должна быть
a or b or c or d - поиск первого правдивого выражение
a  or  b and c  or d - нужно использовать круглые скобки для приоритета