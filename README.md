


## Колбэк функции 

Колбэк функция в Python — это функция, которая передаётся в другую функцию в качестве аргумента и вызывается внутри этой другой функции. Это позволяет сделать код более гибким и расширяемым.

```python
def приветствие(name):
    print(f"Привет, {name}!")


def обработка_имени(callback, name):
    # Здесь вызываем колбэк функцию
    callback(name)

# Передаём функцию приветствие как колбэк
обработка_имени(приветствие, "Алексей")
```


В этом примере:
- Функция `приветствие` принимает имя и выводит приветствие.
- Функция `обработка_имени` принимает функцию (колбэк) и имя, затем вызывает колбэк с переданным именем.

Колбэки часто используют в асинхронном программировании, обработке событий и других сценариях, когда необходимо выполнить некоторую логику по завершении действий.


## Правила работы с функциями

1. Называть функции исходя из выполняемых задач
2. Название функции начинать с _**глагола**_
3. _**Одна**_ функция должна выполнять **_одну задачу**_
4. Не рекомендуется изменять _внешние_ относительно функции _**переменные**_


## Документация функции _**docstring**_

Добавление описания функции

> _**docstring**_ - используется для документирования функций, классов, модулей

```python
def mult_by_factor(value, mult=1):  
    """
    Multiplies number by multiplier.        
    """    
    return value * mult  
  
  
print(mult_by_factor(2))  # 2
print(mult_by_factor(3))  # 3


#Умножает число на множитель
```

```python
def print_number_info(num):  
    """  
    Prints whether number is even or odd  
            Args:       
               num (int): number to be evaluated    """    if (num % 2) == 0:  
        print("Num is even")  
    else:  
        print("Num is  odd")  
  
print_number_info(5)  
  
  
"""  
	Выводит, является ли число четным или нечетным                   
	    Аргументы:  
           num (int): вычисляемое число
"""
```

## Области видимости

> _Область видимости_ - определяет границы действия переменной

_ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ VS ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ_

> Локальные переменные не доступны глобальным, а глобальные, доступны локальным

```python
a = 10  
  
  
def my_fn():  
    a = True  
    b = 15  
    print(a, b)  
  
  
my_fn()  # True 15
  
print(a)  # 10
print(b)
"""
Traceback (most recent call last):
  File "D:\Обучалка\Python\python\main.py", line 11, in <module>
    print(b)
          ^
NameError: name 'b' is not defined

Попытка вывести значение переменной `b` вне функции приведёт к ошибке, так как переменная `b` является локальной для функции `my_fn` и не существует за её пределами.

"""
```

#### Типы областей видимости

1. Глобальная область видимости
2. Область видимости функции

В программировании существует два основных типа областей видимости: **глобальная** и **локальная**.

**Глобальная область видимости** — это область, в которой переменная доступна для использования во всей программе. Она объявляется вне функций и циклов. Переменные, объявленные в глобальной области видимости, доступны для всех функций в коде.

**Локальная область видимости**, напротив, ограничена функцией или блоком кода. Переменная, объявленная внутри функции, доступна только внутри этой функции. Как только выполнение функции завершается, локальные переменные удаляются из памяти.

Когда функция вызывает другую функцию, она создаёт новую область видимости. Это означает, что переменные, объявленные внутри одной функции, не доступны в другой функции, если они не переданы как аргументы или не возвращены как результат.

Важно понимать различия между этими областями видимости, чтобы избежать ошибок и неожиданного поведения программы. Например, изменение глобальной переменной внутри функции может привести к ошибкам, так как другие части программы также могут использовать эту переменную.

Чтобы предотвратить такие проблемы, рекомендуется объявлять переменные в локальной области видимости и передавать их в качестве аргументов функциям, которые в них нуждаются. Это делает код более модульным и упрощает его понимание и отладку.


## Ключевое слово _global_ в функциях

```python
a = 10  
  
  
def my_fn():  
    global b  # вывели переменную в глобальную, тем самым дали доступ к неё
    a = True  
    b = 15  
    print(a, b)  
  
  
my_fn()  # True 15
  
print(a)  # 10 
print(b)  # 15
```


## Операторы

| Арифметические операторы | Операторы сравнения | Логические операторы | Оператор присвоения |
| ------------------------ | ------------------- | -------------------- | ------------------- |
| +                        | ==                  | not                  | =                   |
| -                        | !=                  | and                  |                     |
| *                        | <                   | or                   |                     |
| /                        | >                   | is                   |                     |
|                          | >=                  | is not               |                     |
|                          | <=                  | in                   |                     |
|                          |                     | not in               |                     |

_**is**_ - оператор проверки совпадения объектов

```python
a = 10  
b = a  
c = a + b  
  
print(a is b)  # True совпадение id
print(a is c)  # False не совпадают id
```


### Операторы и магические методы

> У операторов есть соответствующие магические методы классов

```python
a == b 
#равносильно записи ниже
a.__eq__(b)


a = [1,2]  
b = [1,2]  
print(a == b)  # True
  
print(a.__eq__(b))  # True

print(a.__eq__)  # <method-wrapper '__eq__' of list object at 0x000002A3B90DA700>
```

### Функция _**dir**_

> _**dir**_ - выводит список имён атрибутов определённого элемента

```python
print(dir(list))
```

> ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

```python
print(dir(dict))
```

>['__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__ror__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']

### Унарные и бинарные операторы

> Унарные операторы всегда имеют один операнд

```python
my_num = 10  
print(+my_num)
```

В данном коде происходит следующее:

1. Объявление переменной: my_num = 10 — здесь создаётся переменная my_num и ей присваивается значение 10.

2. Вывод значения: print(+my_num) — эта строка выводит значение переменной my_num на экран. Знак + перед переменной не изменяет её значение, он просто указывает, что мы выводим значение как положительное число. В данном случае это избыточно, так как my_num уже положительное.

Таким образом, на экране будет выведено 10.

```python
my_bool = True  
print(+my_bool)
```

При использовании знака + перед булевым значением True, Python автоматически преобразует его в числовой тип. В этом случае True будет преобразовано в 1.

> У бинарных операторов два операнда


```python
a = 5
a + b
a += 5
a == b
a and b
```

### Инфиксная запись

> Инфиксная записьn — это способ записи математических операций, когда оператор находится между операндами. Например, в выражении a + b, оператор + находится между переменными a и b. 

В Python можно использовать инфиксную запись для различных арифметических операций, логических операций и даже операций сравнения.

- Арифметика: x * y, a - b
- Логика: is_true and is_false, x or y
- Сравнение: a < b, c >= d

Инфиксная запись удобна для чтения и восприятия, поскольку она соответствует привычному математическому стилю записи выражений.

#### Операторы _**in, not in**_

```python
my_car = {  
    'brand': 'Ford',  
    'model': 'Mustang',  
}  
  
print('brand' in my_car)  # True
print('model' in my_car)  # True
print('car' in my_car)  # False
print('car' not in my_car)  # True

# Проверка присутствия элемента в последовательности
```

### Ложные значения

> Значение, которое при приведении к логическому типа даёт _false_, является _ложным_

Ложные значения
1. int   0
2. float  0.0
3. complex 0j

Как определить ложное значение? Только вызовом функции _bool_

```python
print(bool(0))  # False
print(bool(0.0))  # False
print(bool(0j))  # False
print(bool(None))  # False
```

Ложными также являются все пустые последовательности

1. dict {}
2. list []
3. tuple ()
4. set set()
5. range range(0)
6.  str ""

```python
print(bool({}))  # False
print(bool([]))  # False
print(bool(()))  # False
print(bool(set()))  # False
print(bool(range(0)))  # False
print(bool(""))  # False
```

bool можно заменить конструкцией not not

```python
print(not not({}))  # False
print(not not([]))  # False
print(not not(()))  # False
print(not not(set()))  # False
print(not not(range(0)))  # False
print(not not(""))  # False
```

## Логические операторы

_**not**_ - всегда возвращает значение типа _bool_
_**and**_ и _**or**_ - возвращает значение одного из операндов

> Оператор _not_ чаще всего используется в условных инструкциях _if_

> Примеры с оператором _not_

```python
print(not 10)  # False
print(not 0)  # True
print(not 'abc')  # False
print(not '')  # True
print(not True)  # False
print(not None)  # True
```

Отрицание отрицания - _not not_

```python
print(not not 10)  # True
print(not not 0)  # False
print(not not 'abc')  # True
print(not not '')  # False
print(not not True)  # True
print(not not None)  # False
```

### Операторы короткого замыкания _or_ и _and_

> Операторы _or_ и _and_ являются операторами короткого замыкания (short-circuit)

> Оператор and - инфиксный бинарный оператор

```python
Выражение 1 and Выражжение 2
```

Если "Выражение 1" ложно:
1. Выражение 2 игнорируется
2. Возвращается результат "Выражение 1"

> Оператор or - инфиксный бинарный оператор, имеет 2 операнда

```python
Выражение 1 or Выражжение 2
```

Если "Выражение 1" истинно:
1. Выражение 2 игнорируется
2. Возвращается результат "Выражение 1"

#### Цепочка операторов _or_ и _and_

a and and b and c and d - везде истина должна быть
a or b or c or d - поиск первого правдивого выражение
a  or  b and c  or d - нужно использовать круглые скобки для приоритета