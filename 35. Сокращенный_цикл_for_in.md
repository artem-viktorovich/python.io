## Сокращенный цикл for in

> Сокращенный for in используется для создания _**новых**_ последовательностей

- list (список)
- dictionary (словарь)
- set (набор)
- tuple (кортеж)

```python
Выражение for Элемент in Последовательность if Условие
```

#### Формирование нового списка в обычном _for in_

> Пример 1

```python
all_nums = [-3, 1, 0, 10, -20, 0]  
absolute_nums = []  
  
for num in all_nums:  
    absolute_nums.append(abs(num))  
  
print(absolute_nums)  
  
print(all_nums)
```

1. Создание списка: all_nums содержит набор чисел: [-3, 1, 0, 10, -20, 0].

2. Инициализация пустого списка: `absolute_nums` создается как пустой список, в который будут добавляться абсолютные значения чисел из `all_nums`.

3. Цикл for: Итерация по каждому элементу num в списке `all_nums`.

4. Функция `abs`: Для каждого числа num вызывается функция `abs(num)`, которая возвращает абсолютное значение (то есть значение без знака).

5. Добавление в новый список: Результат вызова функции `abs(num)` добавляется в список `abcolute_nums` с помощью метода `append`.

6. Вывод результатов: После завершения цикла выводятся списки `absolute_nums` и `all_nums`.

Пример вывода, который будет получен после выполнения данного кода:

```python
[3, 1, 0, 10, 20, 0]
[-3, 1, 0, 10, -20, 0]
```

Таким образом, итоговый список `absolute_nums` содержит абсолютные значения чисел из списка `all_nums`, а оригинальный список `all_nums` остается неизменным.

#### Сокращенный _for in_ для списков (list)

```python
all_nums = [-3, 1, 0, 10, -20, 0]  
abcolute_nums = []  
  
abcolute_nums = [abs(num) for num in all_nums]  
  
print(abcolute_nums)  
  
print(all_nums)
```

#### Формирование нового списка _с фильтрацией_ в обычном _for in_

> Пример 2

```python
all_nums = [-3, 1, 0, 10, -20, 0]  
positive_nums = []  
  
for num in all_nums:  
    if num > 0:  
        positive_nums.append(num)  
  
print(positive_nums)  
  
print(all_nums)
```


1. Создание списка: all_nums содержит набор чисел: [-3, 1, 0, 10, -20, 0].

2. Инициализация пустого списка: positive_nums создается как пустой список, в который будут добавляться положительные числа из all_nums.

3. Цикл `for`: Итерация по каждому элементу num в списке `all_nums`.

4. Условие `if`: Проверяется, является ли текущее число num положительным (больше нуля).

5. Добавление в новый список: Если число положительное, оно добавляется в список `positive_nums` с помощью метода append.

6. Вывод результатов: После завершения цикла выводятся списки `positive_nums` и `all_nums`.

Пример вывода, который будет получен после выполнения данного кода:

```python
[1, 10]
[-3, 1, 0, 10, -20, 0]
```

Таким образом, итоговый список `positive_nums` содержит только положительные числа из списка `all_nums`, а оригинальный список `all_nums` остается неизменным.

#### Сокращенный _for in_ _с фильтрацией_ для списков (list)
 
```python
all_nums = [-3, 1, 0, 10, -20, 0]  
positive_nums = []  
  
positive_nums = [num for num in all_nums if num > 0]  
  
print(positive_nums)  
  
print(all_nums)
```

#### Формирование нового набора в обычном _for in_

> Пример 3

```python
my_set = {1, 10, 15}  
  
new_set = set()  
  
for val in my_set:  
    new_set.add(val * val)  
  
print(new_set)  # {1, 100, 225}
  
print(my_set)  # {1, 10, 15}
```

#### Сокращенный _for in_ для наборов (set)

```python
my_set = {1, 10, 15}  
  
new_set = {val * val for val in my_set}  
  
print(new_set)  # {1, 100, 225}
  
print(my_set)  # {1, 10, 15}
```


#### Формирование нового словаря в обычном _for in_

> Пример 4

```python
my_scores = {  
    'a': 10,  
    'b': 20,  
    'c': 30,  
}  
  
scores = {}  
  
for key, value in my_scores.items():  
    scores[key] = value * 5  
  
print(scores)  # {'a': 50, 'b': 100, 'c': 150}
  
print(my_scores)  # {'a': 10, 'b': 20, 'c': 30}
```

#### Сокращенный _for in_ для словарей (dict)

```python
my_scores = {  
    'a': 10,  
    'b': 20,  
    'c': 30,  
}  
  
scores = {key: value * 5 for key, value in my_scores.items()}  
  
print(scores)  # {'a': 50, 'b': 100, 'c': 150}
  
print(my_scores)  # {'a': 10, 'b': 20, 'c': 30}
```

> Из словарей можно сформировать набор

```python
my_scores = {  
    'a': 10,  
    'b': 20,  
    'c': 30,  
}  
  
scores = {value * 5 for key, value in my_scores.items()}  
  
print(scores)  # {50, 100, 150}
print(type(scores))  # <class 'set'>
```

> Также можно сформировать список

```python
my_scores = {  
    'a': 10,  
    'b': 20,  
    'c': 30,  
}  
  
scores = [value * 5 for key, value in my_scores.items()]  
  
print(scores)  # [50, 100, 150]
print(type(scores))  # <class 'list'>
```

 >Также можно получить из списка словарь, используя встроенную функцию **enumerate()**
 
**Функция enumerate() в Python** **принимает набор данных в качестве параметра и возвращает объект enumerate**. Этот объект возвращается в формате пар ключ-значение, где ключи — это соответствующие индексы элементов, а значения — сами элементы из переданного набора данных. 

**Синтаксис функции enumerate()**: 

enumerate(iterable, start)

**Параметры**:

- **iterable** — это итерируемый объект (список, кортеж и т.д.), который будет возвращён в виде пронумерованного объекта (объекта enumerate). 
- **start** — это начальный индекс для возвращаемого объекта enumerate. Значение по умолчанию равно 0, поэтому, если опустить этот параметр, в качестве первого индекса будет использоваться 0. 

```python
my_scores = [12, 10, 11]  
  
scores = {k:v for k,v in enumerate(my_scores)}  
  
print(scores)  # {0: 12, 1: 10, 2: 11}
print(type(scores))  # <class 'dict'>
```

> Задача 1

- создать словарь с несколькими ключами, значения которых должны быть типа str
- создать новый словарь на основании существующего, в котором значения всех ключей должны быть в верхнем регистре
- результирующий словарь вывести в терминал

> Решение

```python
my_dict = {  
    'car': 'car',  
    'string': 'string'  
}  
  
new_dict = {k: v.upper() for k, v in my_dict.items()}  
  
print(new_dict)  # {'car': 'CAR', 'string': 'STRING'}
```

> Задача 2

- создать список с элементами типа str
- из этого списка создать новый список, в котором останутся только строки, длина которых больше 2
- результирующий список вывести в терминал

> Решение

```python
my_list = ['cars', 'a', 'AC', 'strong']  
  
new_list = [num for num in my_list if len(num) > 2]  
  
print(new_list)  # ['cars', 'strong']
```


## Генераторы в сокращённом _for in_

**Генератор в Python** — это **специальная функция, которая возвращает итератор, с помощью которого можно обойти некоторую последовательность значений**. Отличительной особенностью генераторов является использование ключевого слова yield вместо return для возврата значений. 

**Есть несколько способов создавать генераторы в Python**:

1. **Генераторы на основе функций**. Создаются с помощью ключевого слова yield внутри функции. Когда функция с `yield `вызывается, она возвращает объект-генератор, но не выполняет код внутри функции сразу. Вместо этого выполнение приостанавливается на выражении `yield` и возобновляется при каждом вызове метода `next()` объекта-генератора.
2. **Генераторные выражения**. Они похожи на списковые выражения, но создаются с использованием круглых скобок вместо квадратных. Они также возвращают объект-генератор.

**Генераторы полезны** в тех случаях, когда нужно обрабатывать большие объёмы данных, и не хочется загружать их все в память сразу. Например, можно использовать генератор для чтения большого файла построчно, не загружая его целиком в память.

```python
squares = (num * num for num in range(6))
  
print(squares)  # <generator object <genexpr> at 0x000002623DECF9F0>
print(type(squares))  # <class 'generator'>
for num in squares:  
    print(num)

# 0
# 1
# 4
# 9
# 16
# 25
```

Запись `squares = (num * num for num in range(6)) `создает генераторное выражение в Python. Давайте разберем, как это работает:

1. Генераторное выражение: `num * num for num in range(6)` – это генератор, который будет производить квадраты чисел от 0 до 5. Генератор не создает все значения сразу, а создает их по одному по мере необходимости.

2. Функция `range(6)`: Эта функция возвращает последовательность чисел от 0 до 5 (включительно). То есть, она генерирует числа: 0, 1, 2, 3, 4, 5.

3. Цикл: При выполнении цикла for num in squares: вы фактически итерируете по значениям, которые генерируются выражением `num * num`. Генератор будет вычислять квадрат каждого числа по мере их извлечения, а не заранее.

Когда вы делаете print(squares), вы увидите что-то вроде `<generator object>`, что указывает на то, что `squares` является объектом генератора. 

При выполнении `print(num)` внутри цикла будут выводиться квадраты каждого числа:

```python
0
1
4
9
16
25
```

Таким образом, запись создает "ленивую" последовательность, экономя память, так как не загружает все значения в память сразу.

#### Конвертация генератора в список

```python
nums = [3, 4, 10]  
gen = (num * num for num in nums)  
squares = list(gen)  
print(squares)  # [9, 16, 100]
```

#### Конвертация генератора в кортеж

```python
nums = [3, 4, 10]  
gen = (num * num for num in nums)  
squares = tuple(gen)  
print(squares)  # (9, 16, 100)
```

> ПРЕИМУЩЕСТВО ГЕНЕРАТОРА - РАЗМЕР

```python
from sys import getsizeof  
  
squares_gen = (num * num for num in range(10000))  
print(getsizeof(squares_gen))  # 200
print(type(squares_gen))  # <class 'generator'>
  
squares_list = [num * num for num in range(10000)]  
print(getsizeof(squares_list))  # 85176
print(type(squares_list))  # <class 'list'>
```