## Обработка ошибок

```python
try:  
    # Выполнение блока кода  
    pass  
except ErrorType:  
    # Этот блок выполняется в случае возникновения ошибок в блоке try  
    pass
```


```python
try:  
    print(10 / 0)  
except ZeroDivisionError:  
    print("Error - Devision by zero!")  # Error - Devision by zero!  
print('Continue...')  # Continue...
```

>В блоке try содержится операция, которая может вызвать исключение — в данном случае это деление 10 на ноль (print(10 / 0)). Если произойдёт ZeroDivisionError (деление на ноль), то управление перейдёт к блоку except, где выводится сообщение об ошибке («Error - Devision by zero!») и выполнение программы продолжится со следующего оператора после блока except. Оператор pass используется для того, чтобы просто пропустить блок кода и перейти к следующему оператору.

После блока except идёт оператор print('Continue...'), который выводит на экран текст «Continue...» и показывает, что программа продолжает своё выполнение несмотря на возникшую ошибку.

Таким образом, эта программа демонстрирует обработку исключения ZeroDivisionError с помощью конструкции try-except и позволяет продолжить выполнение программы после возникновения ошибки.

### Получение информации об ошибке

```python
try:  
    print(10 / 0)  
except ZeroDivisionError as e:  
    print(e)  # division by zero
print('Continue...')  # Continue...
```

> В блоке try содержится операция, которая может вызвать исключение — в данном случае это деление 10 на ноль (print(10 / 0)). Если произойдёт ZeroDivisionError (деление на ноль), то управление перейдёт к блоку except. Здесь используется конструкция as e, с помощью которой можно присвоить переменной `e` возникшую ошибку. В результате выполнения блока except на экран будет выведено само сообщение об ошибке.

### Разные типы ошибок

> Что делать в случае возникновения разных типов ошибок?

```python
try:  
    print('10' / 0)  
except ZeroDivisionError as e:  
    print(e)  
print('Continue...')
#Traceback (most recent call last):
  #File "D:\Обучалка\Python\python\main.py", line 2, in <module>
    #print('10' / 0)
          ~~~~~^~~
#TypeError: unsupported operand type(s) for /: 'str' and 'int'
```

> Использовать несколько блоков _**except**_

```python
try:  
    print('10' / 0)  
except ZeroDivisionError as e:  
    print(e)  
except TypeError as e:  
    print(e)  # unsupported operand type(s) for /: 'str' and 'int'
    print('Continue...')  # Continue...
```

В данном фрагменте кода используется обработка исключений в Python. Давайте разберем этот код шаг за шагом.

### Описание функции:

1. Блок try:
   - В этом блоке выполняется код, который может вызывать исключения. В данном случае мы пытаемся выполнить операцию '10' / 0.
   - Эта строка вызывает исключение ZeroDivisionError, так как деление на ноль не определено.

2. Первый блок except (ZeroDivisionError):
   - Если возникает исключение типа ZeroDivisionError, это исключение перехватывается, и выполняется код внутри этого блока.
   - В данном случае будет напечатано сообщение об ошибке, переданное исключением: print(e), где e — это объект исключения, который содержит информацию о произошедшей ошибке.

3. Второй блок except (TypeError):
   - Этот блок предназначен для перехвата исключений типа TypeError. Однако в данном примере не будет вызвано исключение TypeError, поскольку произошло исключение ZeroDivisionError.
   - Если бы ошибка TypeError произошла, исполнился бы код внутри этого блока, который просто выведет строку 'Continue...'.

### Итог:
Код обработает возникшее исключение ZeroDivisionError и выведет соответствующее сообщение об ошибке. Блок для TypeError в данном случае не будет выполнен, так как происходит другая ошибка.

Пример также показывает, как можно структурировать код с обработкой исключений для повышения надежности, позволяя программе продолжать выполнение, даже если произошла ошибка.


### Блоки _else_ и _finally_ в обработке ошибок

```python
try:  
    print(10 / 5)  # 2.0
except ZeroDivisionError as e:  
    print(e)  
except TypeError as e:  
    print(e)  
else:  
    print("Ошибок не возникло")  # Ошибок не возникло
    print('Contunue...')
```

> В этом случае, если ошибок не возникло, блок _else_ выводит нужный нам результат

```python
try:  
    print(10 / 5)  # 2.0
except ZeroDivisionError as e:  
    print(e)  
except TypeError as e:  
    print(e)  
else:  
    print("Ошибок не возникло")  
finally:  
    print('Contunue...')
```

> Блок _finally_ выполняется в любом случае, в не зависимости есть ошибка в блоке  _try_, либо нет

```python
try:  
    print(10 / 0)
except ZeroDivisionError as e:  
    print(isinstance(e, Exception))  
    print(e)  
except TypeError as e:  
    print(e)   finally:  
    print('Contunue...')
```


1. Блок try:
   - В этом блоке выполняется код, который может вызвать исключение. Здесь происходит попытка деления 10 / 0.
   - Поскольку деление на ноль недопустимо, код вызовет исключение ZeroDivisionError.

2. Первый блок except (ZeroDivisionError):
   - Когда возникает исключение ZeroDivisionError, выполнение переходит в этот блок.
   - print(isinstance(e, Exception)): Эта строка проверяет, является ли объект e экземпляром базового класса Exception. Она вернет True, поскольку ZeroDivisionError является подтипом Exception.
   - print(e): Эта строка выводит текстовое представление исключения — обычно это сообщение о делении на ноль.

3. Второй блок except (TypeError):
   - Этот блок предназначен для обработки исключений типа TypeError. В данном случае он не будет выполнен, так как было поймано исключение ZeroDivisionError.

4. Блок finally:
   - Этот блок выполняется в любом случае, независимо от того, произошло исключение или нет. В данном случае будет выведено 'Contunue...'.

### Итог:
Когда код выполнится, он:
- Попытается выполнить деление 10 / 0, что вызовет ZeroDivisionError.
- Перейдет в соответствующий блок except и выведет True (проверка instanceof) и сообщение об ошибке.
- Затем выполнится блок finally, который выведет 'Contunue...'.

### Отсутствие типа ошибок и класс _Exception_

> Если не знаем какая ошибка может быть в блоке try можно использовать блок _Except_, либо класс _Exception_. 


```python
try:  
    print(10 / 0)  
except Exception as e:  
    print(e)  # division by zero
```

```python
try:  
    print(10 / 0)  
except:  
    print('Произошла какая-то ошибка')  # Произошла какая-то ошибка
```

> Не рекомендуется использовать 2ой вариант, так как нет информации об ошибке

### Создание ошибок

#### Генерация ошибки с помощью _raise_

```python
def divide_nums(a, b):  
    if b == 0:  
        raise ValueError("Второй аргумент не может быть равен нулю")  
    return a / b  
  
try:  
    divide_nums(10,0)  
except ValueError as e:  
    print(e)  # Второй аргумент не может быть равен нулю
finally:  
    print('Continue...')
```

Этот код на языке Python определяет функцию `divide_nums`, которая принимает два аргумента, `a` и `b`, и возвращает результат деления `a` на `b`. Внутри функции проверяется условие: если второй аргумент (`b`) равен нулю, то вызывается исключение `ValueError` с сообщением «Второй аргумент не может быть равен нулю». Это предотвращает деление на ноль. 

Затем идёт блок кода, который пытается вызвать функцию `divide_nums` с аргументами 10 и 0. Поскольку второй аргумент равен нулю, возникает исключение `TypeError`, которое обрабатывается блоком `except`. В результате выполнения блока `except` на экран выводится сообщение об ошибке. 

> Задача

1. Создать функцию image_info с одним параметром типа dict
2. Функция ожидает словарь, в котором должно быть как минимум два ключа:
    - image_id
    - image_title
3. Функция должна возвращаться строку такого вида "Image 'my_cat' has id 5136" 
4. Если хотя бы одного из ключей в словаре нет, функция должно генерировать ошибку TypeError

> Решение

```python
def image_info(image_data):
    required_keys = {"image_id", "image_title"}

    if not isinstance(image_data, dict):
        raise TypeError("Функция ожидает словарь")

    for key in required_keys:
        if key not in image_data:
            raise TypeError(f"Не хватает ключа '{key}'")

    image_id = image_data.get("image_id")
    image_title = image_data.get("image_title")
  
    return f"Image '{image_title}' has id {image_id}"

# Пример использования функции
try:
    result = image_info({"image_id": 5136, "image_title": "my_cat"})
except TypeError as e:
    print("Ошибка:", e)
else:
    print(result)

```