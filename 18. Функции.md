## Функции

> _**Функция**_ - блок кода, который можно выполнять многократно

```python
def sum(a, b):  # функция с именем
    c = a + b  # тело функции
    print(c)  


a = 5  
b = 6  
sum(a, b)  # вызов функции

#11

a = 9  
b = 6  
sum(a, b)

#15



"""Функция используется многократно, для вывода разных результатов"""
```

> _**Функция**_ это объект, как всё в Python - <class 'function'>

> Функция возвращает _**None**_, если нет ключевого слова _**return**_

```python
def sum(a, b):  
    c = a + b  
  
print(sum(3, 4))  # None

def sum(a, b):  
    c = a + b  
    return c  
  
print(sum(3, 4))  # 7
```

#### Функция _**pass**_

Функция `pass` в Python используется в качестве заполнителя, когда нужно написать код позже или просто требуется выполнить синтаксическую структуру языка (например, создать тело класса, функции или цикла), но не добавлять никакого конкретного действия.

Это может быть полезно для:

- Создания скелета программы перед добавлением функциональности.
- Формирования шаблонов для будущих функций или классов.
- Указания на то, что блок кода должен быть написан в будущем.

Использование `pass` позволяет избежать ошибок и предупреждений от интерпретатора Python, связанных с отсутствием кода там, где он ожидается.

## Передача неизменяемых объектов в функцию

В Python передача неизменяемых объектов (таких как строки, числа и кортежи) в функции происходит по значению. Это означает, что при передаче объекта в функцию создаётся копия значения аргумента, которая затем используется внутри функции.

При изменении такого объекта внутри функции изменения не будут отражены за пределами функции, так как была создана новая копия. Однако если функция возвращает изменённый объект, то эти изменения будут видны снаружи.

Пример:

```python
def my_function(my_string):
    my_string = my_string + " World!"
    return my_string

my_greeting = "Hello"
modified_greeting = my_function(my_greeting)
print("Inside function:", modified_greeting)  # Prints "Hello World!"
print("Outside function:", my_greeting)     # Prints "Hello"
```

В этом примере строка «Hello» передаётся в функцию `my_function`, где она изменяется. Но поскольку строка является неизменяемым объектом, изменение копии внутри функции не влияет на оригинал. Чтобы увидеть изменения, нужно присвоить результат функции другой переменной.


## Передача изменяемых объектов в функцию

```python
def increase_person_age(person):  
    person['age'] += 1  
    return person  


person_one ={  
    'name': 'Bob',  
    'age': 21,  
}  
  
increase_person_age(person_one)  
print(person_one['age'])  #22
```

В данном примере функция `increase_person_age` принимает один аргумент — словарь `person`, который является изменяемым объектом. Внутри функции значение ключа `'age'` увеличивается на 1 с помощью операции `+=`. Затем функция возвращает изменённый словарь.

В основной части кода создаётся словарь `person_one` с данными о человеке. Затем вызывается функция `increase_person_age`, передавая ей словарь `person_one`. После вызова функции печатается значение ключа `'age'`, которое теперь равно 22.

Таким образом, изменения, сделанные внутри функции, отражаются в исходном словаре, поскольку он был передан по ссылке. Это особенность работы с изменяемыми объектами в Python.

> Внутри функции _**не рекомендуется**_ изменять _**внешние_** объекты

#### Как избежать изменения внешних объектов в функции

```python
def increase_person_age(person):  
    person_copy = person.copy()  #создаём копию внутри функции задавая новую переменную, тем самым не затрагивая внешние ссылки
    person_copy['age'] += 1  
    return person_copy  
  
  
person_one = {  
    'name': 'Bob',  
    'age': 21,  
}  
  
new_person = increase_person_age(person_one)  
print(new_person['age'])  #22
print(person_one['age'])  #21
```

Чтобы избежать изменения внешних объектов в функции в Python, можно использовать несколько подходов:

1. **Копирование объекта.** Создайте копию переданного объекта внутри функции с помощью методов копирования или срезов. Это позволит вам работать с копией объекта, не затрагивая оригинальный объект.
    
2. **Использование неизменяемых типов данных.** Если возможно, используйте неизменяемые типы данных, такие как строки, числа и кортежи. Они не могут быть изменены после создания, что предотвращает случайное изменение внешних объектов.
    
3. **Возврат нового объекта.** Вместо изменения переданного объекта создайте новый объект внутри функции и верните его. Таким образом, вы сможете контролировать, какие изменения будут внесены во внешний мир.
    
4. **Передача копии объекта.** При вызове функции передайте копию объекта, используя методы копирования или срезы. Это гарантирует, что функция будет работать только с копией, а не с исходным объектом.
    
5. **Использование аргументов только для чтения.** В некоторых случаях можно использовать аргументы только для чтения, чтобы предотвратить их изменение внутри функции. Однако это может привести к ошибкам, если функция попытается изменить объект, который был передан как аргумент только для чтения.
    
6. **Применение функций высшего порядка.** Используйте функции высшего порядка, которые принимают другие функции в качестве аргументов и возвращают новые функции. Это позволяет контролировать доступ к внешним объектам и предотвращать их случайное изменение.
    
7. **Использование контекстных менеджеров.** Контекстные менеджеры предоставляют возможность управлять ресурсами и объектами, гарантируя их безопасное использование и освобождение. Они могут помочь предотвратить случайное изменение объектов внутри функции.
    
8. **Возвращение изменённого объекта.** Верните изменённый объект из функции, но сохраните исходный объект без изменений. Это даст возможность контролировать процесс внесения изменений и при необходимости откатиться к первоначальному состоянию.
    

Выбор подхода зависит от конкретной ситуации и требований  проекта.

> Задача
- Создайте функцию merge_lists_to_dict
- У функции должно быть два параметра
- Функция должна объединить два списка, используя встроенную функцию zip
- Конвертируйте объект zip в словарь и верните его из функции
- Вызовите функцию, передав ей два списка в качестве аргументов
- Выведите результат вызова функции в терминал

>Решение

```python
def  merge_lists_to_dict(a, b):  
    create_zip_list = zip(a, b)  # <zip object at 0x000002BC6A8FC4C0>
    create_dict_list = dict(create_zip_list)  
    return create_dict_list
  
  
list1 = [1, 2, 3]  
list2 = [4, 5, 6]  
  
result = merge_lists_to_dict(list1, list2)  
print(result)  #{1: 4, 2: 5, 3: 6}
```